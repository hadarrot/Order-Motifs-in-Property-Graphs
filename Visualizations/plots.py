# -*- coding: utf-8 -*-
"""vldb26.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1L5DfpKBLqzhQDYiEIHMtNAz_in7mmrrH

# Property Graph
"""

import networkx as nx
import matplotlib.pyplot as plt
import matplotlib.patches as mpatches
import numpy as np

def draw_graph():
    G = nx.DiGraph()
    # ... [nodes_data and edges_data remain the same as your previous code] ...
    nodes_data = {
        1: {"name": "Liam", "city": "London"}, 2: {"name": "Noah", "city": "Paris"},
        3: {"name": "Olivia", "city": "New York"}, 4: {"name": "Emma", "city": "Berlin"},
        5: {"name": "Ava", "city": "Tokyo"}, 6: {"name": "James", "city": "Sydney"},
        7: {"name": "Sophia", "city": "Rome"}, 8: {"name": "Mason", "city": "Dubai"},
    }
    for n_id, attrs in nodes_data.items(): G.add_node(n_id, **attrs)

    edges_data = [
        (1, 2, {"amount": 10000, "date": "Feb 12"}), (2, 4, {"amount": 15000, "date": "Mar 05"}),
        (3, 4, {"amount": 50000, "date": "Mar 15"}), (4, 5, {"amount": 20000, "date": "Apr 10"}),
        (4, 6, {"amount": 60000, "date": "Apr 22"}), (5, 7, {"amount": 5000,  "date": "May 08"}),
        (6, 8, {"amount": 100000,"date": "Jun 01"}), (4, 2, {"amount": 2500,  "date": "Mar 10"}),
        (7, 5, {"amount": 1200,  "date": "May 20"}),
    ]
    for u, v, attrs in edges_data: G.add_edge(u, v, **attrs)

    # 4. Manual Layout
    pos = {
        1: (-1.0, 1.5), 2: (0.0, 0.5), 3: (0.8, 1.6), 4: (2.4, 0.8),
        5: (4.5, 0.5), 6: (4.0, 1.6), 7: (6.5, 0.5), 8: (6.5, 1.2),
    }

    # 5. Visualization setup
    plt.figure(figsize=(14, 6)) # Increased width to prevent horizontal cutting
    ax = plt.gca()
    node_size = 8500

    # Draw Nodes & Labels
    node_labels = {n: f"name: {d['name']}\ncity: {d['city']}" for n, d in G.nodes(data=True)}
    nx.draw_networkx_nodes(G, pos, node_size=node_size, node_color='#e6f2ff', edgecolors='black', ax=ax)
    nx.draw_networkx_labels(G, pos, labels=node_labels, font_size=9, font_weight='bold')

    # Draw Edges (handling curves)
    for u, v, d in G.edges(data=True):
        start, end = np.array(pos[u]), np.array(pos[v])
        rad = 0.2 if G.has_edge(v, u) else 0.0

        arrow = mpatches.FancyArrowPatch(
            start, end, arrowstyle='-|>', mutation_scale=25, color='#555555',
            connectionstyle=f"arc3,rad={rad}", shrinkA=55, shrinkB=55, lw=2, zorder=1
        )
        ax.add_patch(arrow)

        # Edge label logic
        midpoint = (start + end) / 2
        direction = end - start
        norm = np.linalg.norm(direction)
        normal = np.array([-direction[1], direction[0]]) / norm if norm > 0 else [0,0]
        label_pos = midpoint + (normal * (0.25 if rad else 0.1))

        ax.text(label_pos[0], label_pos[1], f"amount: ${d['amount']:,}\ndate: {d['date']}",
                size=8, ha='center', va='center', bbox=dict(boxstyle="round,pad=0.3", fc="white", ec="black"), zorder=2)

    # --- THE FIX FOR CUTTING ---
    # 1. Manually set limits slightly beyond your min/max coordinates
    ax.set_xlim(-2.0, 7.5)
    ax.set_ylim(0.0, 2.0)

    # 2. Turn off axis but keep the frame tight
    plt.axis('off')

    # 3. Save with tight bounding box and minimal padding
    plt.savefig("property_graph.png", dpi=300, bbox_inches='tight', pad_inches=0.1)
    plt.show()

if __name__ == "__main__":
    draw_graph()

"""# Exp2"""

import pandas as pd
import io
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np
from matplotlib.lines import Line2D

# --- 1. Data Loading ---

# DATASET A: Unbounded (From your latest prompt)
data_unbounded_str = """Nodes Density Edges B.Mean(ms) B.Std(ms) B.TO Build(ms) L.Mean(ms) L.Std(ms) L.TO Speedup
100 1.0 100 104.22 89.52 0 71.67 11.30 13.83 0 1.26
100 5.0 500 0.00 0.00 3 63.96 46.49 33.14 0 inf
100 10.0 1000 0.00 0.00 3 53.68 447.89 118.06 0 inf
1000 1.0 1000 12817.24 190.38 0 98.47 30.52 24.07 0 99.37
1000 5.0 5000 0.00 0.00 3 193.81 77.42 29.72 0 inf
1000 10.0 10000 0.00 0.00 3 518.88 4071.84 295.49 0 inf
10000 1.0 10000 0.00 0.00 3 456.56 53.06 26.02 0 inf
10000 5.0 50000 0.00 0.00 3 1846.31 363.01 40.50 0 inf
10000 10.0 100000 0.00 0.00 3 6641.80 46754.92 820.32 0 inf
100000 1.0 100000 0.00 0.00 3 4701.61 181.57 95.20 0 inf
100000 5.0 500000 0.00 0.00 3 16530.69 5080.26 65.67 0 inf
100000 10.0 1000000 0.00 0.00 3 47697.96 0.00 0.00 3 TO
1000000 1.0 1000000 0.00 0.00 3 41396.20 852.94 59.29 0 inf
1000000 5.0 5000000 0.00 0.00 3 178188.72 0.00 0.00 3 TO
1000000 10.0 10000000 0.00 0.00 3 916501.40 0.00 0.00 3 TO
"""

# DATASET B: Bounded (From previous turn)
data_bounded_str = """Nodes Density Edges Hops B.Mean(ms) B.Std(ms) B.TO Build(ms) L.Mean(ms) L.Std(ms) L.TO Speedup
100 1.0 100 2 8.03 2.75 0 51.14 7.21 2.78 0 0.14
100 1.0 100 4 17.25 10.57 0 51.14 14.11 18.14 0 0.26
100 1.0 100 8 24.49 18.10 0 51.14 10.40 11.61 0 0.40
100 1.0 100 16 31.23 16.72 0 51.14 20.88 25.41 0 0.43
100 1.0 100 32 30.90 6.26 0 32.70 7.42 6.11 0 0.77
100 1.0 100 64 69.25 25.69 0 32.70 15.98 18.36 0 1.42
100 5.0 500 2 19.75 12.08 0 57.04 13.49 7.90 0 0.28
100 5.0 500 4 144.73 14.07 0 57.04 15.44 14.06 0 2.00
100 5.0 500 8 0.00 0.00 3 57.04 31.89 18.18 0 inf
100 5.0 500 16 0.00 0.00 3 57.04 29.29 14.74 0 inf
100 5.0 500 32 0.00 0.00 3 44.64 28.98 13.66 0 inf
100 5.0 500 64 0.00 0.00 3 44.64 28.00 13.92 0 inf
100 10.0 1000 2 26.60 8.19 0 51.19 16.12 9.87 0 0.40
100 10.0 1000 4 1404.59 64.96 0 51.19 37.30 15.02 0 15.87
100 10.0 1000 8 0.00 0.00 3 51.19 141.02 13.53 0 inf
100 10.0 1000 16 0.00 0.00 3 51.19 368.39 58.53 0 inf
100 10.0 1000 32 0.00 0.00 3 48.86 404.13 70.66 0 inf
100 10.0 1000 64 0.00 0.00 3 48.86 393.72 59.79 0 inf
1000 1.0 1000 2 18.58 9.94 0 95.28 22.36 22.25 0 0.16
1000 1.0 1000 4 31.57 17.97 0 95.28 20.53 20.74 0 0.27
1000 1.0 1000 8 41.13 21.45 0 95.28 18.42 15.54 0 0.36
1000 1.0 1000 16 72.85 18.38 0 95.28 8.45 2.51 0 0.70
1000 1.0 1000 32 136.83 10.87 0 66.38 17.26 15.51 0 1.64
1000 1.0 1000 64 429.45 17.58 0 66.38 8.50 2.31 0 5.74
1000 5.0 5000 2 68.33 21.27 0 250.08 21.48 10.00 0 0.25
1000 5.0 5000 4 1003.70 99.95 0 250.08 39.47 14.85 0 3.47
1000 5.0 5000 8 0.00 0.00 3 250.08 66.38 12.44 0 inf
1000 5.0 5000 16 0.00 0.00 3 250.08 65.98 13.50 0 inf
1000 5.0 5000 32 0.00 0.00 3 183.07 85.52 32.53 0 inf
1000 5.0 5000 64 0.00 0.00 3 183.07 74.94 19.39 0 inf
1000 10.0 10000 2 133.78 34.40 0 471.84 49.63 32.01 0 0.26
1000 10.0 10000 4 12761.68 401.04 0 471.84 109.67 10.15 0 21.95
1000 10.0 10000 8 0.00 0.00 3 471.84 1083.35 43.89 0 inf
1000 10.0 10000 16 0.00 0.00 3 471.84 3666.57 312.61 0 inf
1000 10.0 10000 32 0.00 0.00 3 396.69 4140.96 275.50 0 inf
1000 10.0 10000 64 0.00 0.00 3 396.69 4145.58 291.78 0 inf
10000 1.0 10000 2 50.05 18.38 0 378.71 29.69 16.47 0 0.12
10000 1.0 10000 4 73.47 13.69 0 378.71 29.59 13.65 0 0.18
10000 1.0 10000 8 130.20 18.03 0 378.71 34.42 11.37 0 0.32
10000 1.0 10000 16 320.97 18.63 0 378.71 33.83 13.12 0 0.78
10000 1.0 10000 32 910.49 12.75 0 406.51 34.65 10.90 0 2.06
10000 1.0 10000 64 3270.32 23.24 0 406.51 33.64 12.28 0 7.43
10000 5.0 50000 2 257.81 52.70 0 1507.29 68.42 11.08 0 0.16
10000 5.0 50000 4 8059.48 190.17 0 1507.29 156.52 21.65 0 4.84
10000 5.0 50000 8 0.00 0.00 3 1507.29 308.97 4.29 0 inf
10000 5.0 50000 16 0.00 0.00 3 1507.29 340.73 7.33 0 inf
10000 5.0 50000 32 0.00 0.00 3 1455.23 345.13 16.07 0 inf
10000 5.0 50000 64 0.00 0.00 3 1455.23 339.67 15.34 0 inf
10000 10.0 100000 2 825.78 59.35 0 4504.60 132.17 10.34 0 0.18
10000 10.0 100000 4 0.00 0.00 3 4504.60 921.09 102.58 0 inf
10000 10.0 100000 8 0.00 0.00 3 4504.60 11960.77 77.55 0 inf
10000 10.0 100000 16 0.00 0.00 3 4504.60 43111.56 489.49 0 inf
10000 10.0 100000 32 0.00 0.00 3 4533.70 45865.11 1166.53 0 inf
10000 10.0 100000 64 0.00 0.00 3 4533.70 46254.59 1498.45 0 inf
100000 1.0 100000 2 171.30 26.18 0 4183.19 95.23 11.82 0 0.04
100000 1.0 100000 4 372.81 31.39 0 4183.19 105.07 13.77 0 0.09
100000 1.0 100000 8 991.01 130.05 0 4183.19 107.61 13.31 0 0.23
100000 1.0 100000 16 2786.85 31.08 0 4183.19 105.32 7.47 0 0.65
100000 1.0 100000 32 8620.58 54.33 0 4149.07 112.43 18.14 0 2.02
100000 1.0 100000 64 32285.47 129.03 0 4149.07 112.25 13.82 0 7.58
100000 5.0 500000 2 2119.22 17.46 0 15954.79 439.16 8.38 0 0.13
100000 5.0 500000 4 0.00 0.00 3 15954.79 1743.41 6.57 0 inf
100000 5.0 500000 8 0.00 0.00 3 15954.79 4437.20 49.43 0 inf
100000 5.0 500000 16 0.00 0.00 3 15954.79 4847.19 47.03 0 inf
100000 5.0 500000 32 0.00 0.00 3 16419.28 5102.73 62.58 0 inf
100000 5.0 500000 64 0.00 0.00 3 16419.28 5095.02 95.11 0 inf
100000 10.0 1000000 2 9159.81 329.36 0 47156.83 1273.45 28.15 0 0.19
100000 10.0 1000000 4 0.00 0.00 3 47156.83 14045.84 32.07 0 inf
100000 10.0 1000000 8 0.00 0.00 3 47156.83 0.00 0.00 3 0.00
100000 10.0 1000000 16 0.00 0.00 3 47156.83 0.00 0.00 3 0.00
100000 10.0 1000000 32 0.00 0.00 3 45769.43 0.00 0.00 3 inf
100000 10.0 1000000 64 0.00 0.00 3 45769.43 0.00 0.00 3 inf
1000000 1.0 1000000 2 1391.61 291.19 0 41186.58 636.31 24.76 0 0.03
1000000 1.0 1000000 4 3195.27 56.92 0 41186.58 763.40 24.04 0 0.08
1000000 1.0 1000000 8 8999.40 164.08 0 41186.58 754.87 18.66 0 0.21
1000000 1.0 1000000 16 28196.14 159.60 0 41186.58 763.87 28.03 0 0.67
1000000 1.0 1000000 32 0.00 0.00 3 41515.29 873.82 51.57 0 inf
1000000 1.0 1000000 64 0.00 0.00 3 41515.29 845.68 10.06 0 inf
1000000 5.0 5000000 2 23964.87 903.04 0 189413.34 5228.20 28.53 0 0.12
1000000 5.0 5000000 4 0.00 0.00 3 189413.34 21244.92 400.22 0 inf
1000000 5.0 5000000 8 0.00 0.00 3 189413.34 55382.44 193.29 0 inf
1000000 5.0 5000000 16 0.00 0.00 3 189413.34 0.00 0.00 3 0.00
1000000 5.0 5000000 32 0.00 0.00 3 175646.34 0.00 0.00 3 inf
1000000 5.0 5000000 64 0.00 0.00 3 175646.34 0.00 0.00 3 inf
1000000 10.0 10000000 2 0.00 0.00 3 891540.26 0.00 0.00 3 0.00
1000000 10.0 10000000 4 0.00 0.00 3 891540.26 0.00 0.00 3 0.00
1000000 10.0 10000000 8 0.00 0.00 3 891540.26 0.00 0.00 3 0.00
1000000 10.0 10000000 16 0.00 0.00 3 891540.26 0.00 0.00 3 0.00
1000000 10.0 10000000 32 0.00 0.00 3 781531.01 0.00 0.00 3 inf
1000000 10.0 10000000 64 0.00 0.00 3 781531.01 0.00 0.00 3 inf
"""

# Read into DataFrames
df_unbounded = pd.read_csv(io.StringIO(data_unbounded_str), sep=r'\s+')
df_bounded = pd.read_csv(io.StringIO(data_bounded_str), sep=r'\s+')

# Rename columns for consistency
col_map = {'B.Mean(ms)': 'B.Mean', 'L.Mean(ms)': 'L.Mean', 'Build(ms)': 'Build'}
df_unbounded.rename(columns=col_map, inplace=True)
df_bounded.rename(columns=col_map, inplace=True)


# --- 2. Configuration & Logic ---
TIMEOUT_THRESHOLD = 60000  # 60s in ms
TIMEOUT_VAL = 2 * 10**7    # Visual ceiling value for plotting
TIMEOUT_COLOR = 'gray'

sns.set_theme(style="whitegrid", context="paper", font_scale=1.2)
plt.rcParams['font.family'] = 'serif'
distinct_palette = sns.color_palette("colorblind", n_colors=3)

def calculate_plot_latencies(df_in):
    """
    1. Leveled = Build + L.Mean
    2. Native = B.Mean
    3. Handles timeouts (returns TIMEOUT_VAL)
    """
    df_out = df_in.copy()

    # --- Process Native (Baseline) ---
    def get_native_val(row):
        # Explicit timeout flag in data OR 0.00 mean (per data schema)
        if row['B.TO'] > 0 or row['B.Mean'] == 0.00:
            return TIMEOUT_VAL
        if row['B.Mean'] > TIMEOUT_THRESHOLD:
            return TIMEOUT_VAL
        return row['B.Mean']

    # --- Process Leveled (Proposed) ---
    def get_leveled_val(row):
        # Explicit timeout flag in data
        if row['L.TO'] > 0:
            return TIMEOUT_VAL

        # NOTE: Some data points have L.Mean=0.00 but L.TO=0 (very fast).
        # Only treat 0.00 as timeout if L.TO > 0 (handled above).

        # Calculate Total Cost = Build Time + Query Time
        total_time = row['Build'] + row['L.Mean']

        # Check against 60s threshold
        if total_time > TIMEOUT_THRESHOLD:
            return TIMEOUT_VAL

        return total_time

    df_out['B.Plot'] = df_out.apply(get_native_val, axis=1)
    df_out['L.Plot'] = df_out.apply(get_leveled_val, axis=1)

    return df_out

# Apply calculations
df_unbounded = calculate_plot_latencies(df_unbounded)
df_bounded = calculate_plot_latencies(df_bounded)

# --- 3. Plotting Helper ---
def plot_split_series(sub_df, x_col, y_col, color, style, marker_size):
    sub_df = sub_df.sort_values(x_col)
    xs = sub_df[x_col].values
    ys = sub_df[y_col].values

    for i in range(len(xs) - 1):
        x1, y1 = xs[i], ys[i]
        x2, y2 = xs[i+1], ys[i+1]

        # Draw line segment
        if y2 == TIMEOUT_VAL and y1 < TIMEOUT_VAL:
            # Transition to Timeout -> Grey line rising
            plt.plot([x1, x2], [y1, y2], color=TIMEOUT_COLOR, linestyle=style,
                     linewidth=1.5, zorder=1)
        elif y1 == TIMEOUT_VAL and y2 == TIMEOUT_VAL:
            # Both are timeout -> Don't draw line on ceiling (cleaner look)
            pass
        elif y1 == TIMEOUT_VAL and y2 < TIMEOUT_VAL:
             # Coming back from timeout (unlikely in scalability, but possible)
             plt.plot([x1, x2], [y1, y2], color=TIMEOUT_COLOR, linestyle=style,
                     linewidth=1.5, zorder=1)
        else:
            # Standard valid segment -> Color line
            plt.plot([x1, x2], [y1, y2], color=color, linestyle=style,
                     linewidth=2, marker='o', markersize=marker_size, zorder=3)

    # Ensure markers are plotted
    for i in range(len(xs)):
        if ys[i] == TIMEOUT_VAL:
             # Optional: Draw a small grey dot on the ceiling
             plt.plot(xs[i], ys[i], color=TIMEOUT_COLOR, marker='.', zorder=2)
        else:
             pass # Logic above handles markers for valid lines usually

def create_latency_plot(dataframe, title_suffix, filename):
    plt.figure(figsize=(7, 5))
    ax = plt.gca()

    density_vals = sorted(dataframe['Density'].unique())
    for i, dens in enumerate(density_vals):
        subset = dataframe[dataframe['Density'] == dens]
        color = distinct_palette[i]

        # Plot Leveled (Solid)
        plot_split_series(subset, 'Nodes', 'L.Plot', color, '-', 6)
        # Plot Native (Dashed)
        plot_split_series(subset, 'Nodes', 'B.Plot', color, '--', 6)

    # Legends
    lines = [Line2D([0], [0], color=c, lw=2) for c in distinct_palette]
    labels = ['1.0', '5.0', '10.0']
    leg1 = plt.legend(lines, labels, title='Density', loc='upper left')
    ax.add_artist(leg1)

    style_lines = [
        Line2D([0], [0], color='black', lw=2, linestyle='-', label='Leveled\n(Build+Query)'),
        Line2D([0], [0], color='black', lw=2, linestyle='--', label='Native'),
    ]
    plt.legend(handles=style_lines, loc='lower right', title='Method')

    # Formatting
    plt.xscale('log')
    plt.yscale('log')
    plt.xlabel('Nodes')
    plt.ylabel('Latency (ms)')
    # plt.title(f'Latency: Native vs. Leveled ({title_suffix})')

    # Y-Axis Ticks & Labels
    plt.ylim(bottom=10, top=TIMEOUT_VAL * 2.5)
    current_ticks = list(plt.yticks()[0])
    filtered_ticks = [t for t in current_ticks if t < TIMEOUT_VAL / 10]
    filtered_ticks.append(TIMEOUT_VAL)
    ax.set_yticks(filtered_ticks)

    labels_list = []
    for t in filtered_ticks:
        if t == TIMEOUT_VAL:
            labels_list.append("T.O.")
        else:
            labels_list.append(f'$10^{{{int(np.log10(t))}}}$')
    ax.set_yticklabels(labels_list)

    plt.tight_layout()
    plt.savefig(filename)
    plt.show()

# --- 4. Execution ---


# 2. Length = 2 Plot
df_len2 = df_bounded[df_bounded['Hops'] == 2].copy()
create_latency_plot(df_len2, "Length=2", "fig_exp2_len2.pdf")

# 3. Length = 64 Plot
df_len64 = df_bounded[df_bounded['Hops'] == 64].copy()
create_latency_plot(df_len64, "Length=64", "fig_exp2_len64.pdf")

# 1. Unbounded Plot
create_latency_plot(df_unbounded, "Unbounded", "fig_exp2_unbounded.pdf")

"""## Exp 3"""

import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np

def apply_style():
    """Applies the specific style requested by the user."""
    sns.set_theme(style="whitegrid", context="paper", font_scale=1.2)
    plt.rcParams['font.family'] = 'serif'
    return sns.color_palette("colorblind", n_colors=3)

def plot_fig1_styled(palette):
    # --- UPDATED DATA FROM LOGS ---
    lengths = ['32', '64', '128', '256', '512', '1024', 'Unbounded']

    # Native times (ms)
    # For 256, 512, 1024, Unbounded, the latency is 0.00 with failure count 3 -> Timeout (60000ms)
    native_times = [
        1031.59,    # L32
        3880.37,    # L64
        15569.58,   # L128
        60000,      # L256 (Timeout)
        60000,      # L512 (Timeout)
        60000,      # L1024 (Timeout)
        60000       # Unbounded (Timeout)
    ]

    # Leveled times (ms)
    # Build Cost is constant for this configuration in the logs: 680.55
    build_cost = 680.55

    # Query Costs from logs
    query_costs = [
        45.83,  # L32
        44.32,  # L64
        43.12,  # L128
        45.80,  # L256
        50.26,  # L512
        63.51,  # L1024
        51.59   # Unbounded
    ]

    # Total Leveled Time = Build + Query
    leveled_times = [build_cost + q for q in query_costs]

    # --- PLOTTING ---
    fig, ax1 = plt.subplots(figsize=(8, 5))
    x = np.arange(len(lengths))
    width = 0.35

    # Plot Bars
    ax1.bar(x - width/2, native_times, width, label='Native (Runtime)',
                     color=palette[1], alpha=0.9, edgecolor='white', linewidth=1)
    ax1.bar(x + width/2, leveled_times, width, label='Leveled (Build + Query)',
                     color=palette[0], alpha=0.9, edgecolor='white', linewidth=1)

    # Labels and Title
    ax1.set_ylabel('Latency (ms)', fontsize=12)
    ax1.set_xlabel('Path Length Constraint', fontsize=12)
    ax1.set_title('Native vs. Leveled Performance\n(Density 1.0, 10k Nodes)', fontsize=14)
    ax1.set_xticks(x)
    ax1.set_xticklabels(lengths)

    # Log Scale Settings
    ax1.set_yscale('log')
    ax1.set_ylim(100, 100000) # Set upper limit to accommodate text

    # --- CUSTOM Y-AXIS TICKS FOR INFINITY ---
    ticks = [100, 1000, 10000, 60000]
    labels = ['100', '1,000', '10,000', r'$\infty$']

    ax1.set_yticks(ticks)
    ax1.set_yticklabels(labels)
    # ----------------------------------------

    # Legend
    ax1.legend(loc='upper left', frameon=True)

    # Timeout Line at 60s
    ax1.axhline(y=60000, color='.3', linestyle=':', linewidth=2)

    # Add "TIMEOUT" labels for the saturated bars
    # We place text slightly above the bar.
    # Since y-axis is log scale, 65000 is a good position above 60000.
    for i, val in enumerate(native_times):
        if val >= 60000:
            ax1.text(i - width/2, 68000, 'TIMEOUT',
                     ha='center', va='bottom',
                     color=palette[1], fontweight='bold', fontsize=9)

    plt.tight_layout()
    plt.savefig('exp3_time_comparison.pdf')
    plt.show()
    plt.close()
    print("Saved exp3_time_comparison.pdf")

if __name__ == "__main__":
    distinct_palette = apply_style()
    plot_fig1_styled(distinct_palette)

"""# Horizontal Comparison"""

import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd
import numpy as np
from matplotlib.ticker import FixedLocator

# ==========================================
# 1. STYLE CONFIGURATION
# ==========================================
def set_style():
    sns.set_theme(style="whitegrid", context="paper", font_scale=1.4)
    plt.rcParams['font.family'] = 'serif'
    plt.rcParams['axes.edgecolor'] = '.3'
    plt.rcParams['axes.linewidth'] = 1.0
    return ["#0072B2", "#D55E00", "#009E73"]  # Color-blind friendly palette

palette = set_style()

# ==========================================
# 2. DATA INPUT (From Tables 1 & 3 in PDF)
# ==========================================

# Visual Y-value for "Infinity"
INF_Y = 300

# --- Monotonic (Table 1: Density 1.0, 10^4 Nodes) ---
# Source: Table 1, Row 10^4.
# L2: 0.12, L4: 0.18, L8: 0.32, L16: 0.78, L32: 2.94, L64: 7.23, L128: 28.13, L256: 109.78
# L512 and L1024 are Infinite (Native T.O.)
mono_finite = {
    2: 0.12, 4: 0.18, 8: 0.32, 16: 0.78,
    32: 2.94, 64: 7.23, 128: 28.13, 256: 109.78
}

# --- Peak (UD) (Table 3: Density 1.0, 10^4 Nodes) ---
# Source: Table 3, Row 'UD'.
# L2: 0.06, L4: 0.06, L8: 0.13, L16: 0.28, L32: 0.80, L64: 3.34, L128: 11.63
# L256+ are Infinite.
peak_finite = {
    2: 0.06, 4: 0.06, 8: 0.13, 16: 0.28,
    32: 0.80, 64: 3.34, 128: 11.63
}

# --- ZigZag (UDUDU) (Table 3: Density 1.0, 10^4 Nodes) ---
# Source: Table 3, Row 'UDUDU'.
# L2: 0.03, L4: 0.03, L8: 0.03, L16: 0.08, L32: 0.32, L64: 1.16, L128: 4.59
# L256+ are Infinite.
zigzag_finite = {
    2: 0.03, 4: 0.03, 8: 0.03, 16: 0.08,
    32: 0.32, 64: 1.16, 128: 4.59
}

# Helper to create DataFrames
def create_df(data_dict, motif_name):
    return pd.DataFrame([
        {'Length': k, 'Speedup': v, 'Motif': motif_name}
        for k, v in data_dict.items()
    ])

df_mono = create_df(mono_finite, 'Monotonic')
df_peak = create_df(peak_finite, 'Peak (UD)')
df_zig = create_df(zigzag_finite, 'ZigZag (UDUDU)')

# ==========================================
# 3. PLOTTING
# ==========================================
fig, ax = plt.subplots(figsize=(8, 6))

# --- A. Plot Finite Segments ---
# Monotonic
ax.plot(df_mono['Length'], df_mono['Speedup'], label='Monotonic',
        color=palette[0], marker='o', linestyle='-', linewidth=2.5, markersize=8, zorder=3)

# Peak (UD)
ax.plot(df_peak['Length'], df_peak['Speedup'], label='Peak (UD)',
        color=palette[1], marker='s', linestyle='--', linewidth=2.5, markersize=8, zorder=3)

# ZigZag (UDUDU)
ax.plot(df_zig['Length'], df_zig['Speedup'], label='ZigZag (UDUDU)',
        color=palette[2], marker='^', linestyle=':', linewidth=2.5, markersize=8, zorder=3)


# --- B. Plot "Infinity" Transitions ---

# 1. Monotonic: Valid at 256 -> Infinite at 512
ax.plot([256, 512], [109.78, INF_Y], color=palette[0], linestyle='-', linewidth=2.5, alpha=0.6, zorder=2)
ax.scatter([512, 1024], [INF_Y]*2, color='white', edgecolors=palette[0], s=100, linewidth=2.5, zorder=4)
ax.plot([512, 1024], [INF_Y, INF_Y], color=palette[0], linestyle='-', linewidth=2.5, alpha=0.6, zorder=2)

# 2. Peak (UD): Valid at 128 -> Infinite at 256
ax.plot([128, 256], [11.63, INF_Y], color=palette[1], linestyle='--', linewidth=2.5, alpha=0.6, zorder=2)
ax.scatter([256, 512, 1024], [INF_Y]*3, color='white', edgecolors=palette[1], marker='s', s=80, linewidth=2.5, zorder=4)
ax.plot([256, 1024], [INF_Y, INF_Y], color=palette[1], linestyle='--', linewidth=2.5, alpha=0.6, zorder=2)

# 3. ZigZag (UDUDU): Valid at 128 -> Infinite at 256
ax.plot([128, 256], [4.59, INF_Y], color=palette[2], linestyle=':', linewidth=2.5, alpha=0.6, zorder=2)
ax.scatter([256, 512, 1024], [INF_Y]*3, color='white', edgecolors=palette[2], marker='^', s=80, linewidth=2.5, zorder=4)
ax.plot([256, 1024], [INF_Y, INF_Y], color=palette[2], linestyle=':', linewidth=2.5, alpha=0.6, zorder=2)


# --- C. Break-Even Line ---
ax.axhline(y=1, color='.4', linestyle='-', linewidth=1.5, alpha=0.5)
ax.text(2, 1.15, "Break-Even (Speedup > 1)", color='.3', fontsize=10, fontweight='bold')

# ==========================================
# 4. AXIS FORMATTING
# ==========================================
ax.set_xscale('log', base=2)
ax.set_yscale('log')

# X-Axis
ticks_x = [2, 4, 8, 16, 32, 64, 128, 256, 512, 1024]
ax.set_xticks(ticks_x)
ax.set_xticklabels([str(t) for t in ticks_x])
ax.set_xlim(1.8, 1100)

# Y-Axis (Custom Ticks to show Infinity)
ax.set_ylim(0.01, INF_Y * 1.5)
yticks = [0.01, 0.1, 1, 10, 100, INF_Y]
ytick_labels = ['0.01', '0.1', '1', '10', '100', r'$\infty$']
ax.yaxis.set_major_locator(FixedLocator(yticks))
ax.set_yticklabels(ytick_labels)

# Highlight Infinity Label
ax.get_yticklabels()[-1].set_fontsize(16)
ax.get_yticklabels()[-1].set_color('#333333')

ax.set_xlabel('Path Length')
ax.set_ylabel('Speedup Factor (Log Scale)')
# ax.set_title('Impact of Motif Complexity on Speedup')

ax.legend(title='Motif Type', loc='lower right', frameon=True, framealpha=0.9)

plt.tight_layout()
plt.savefig('comparison_complexity_speedup.pdf')
print("Saved comparison_complexity_speedup.pdf")
plt.show()

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np

# ==========================================
# 1. CONFIGURATION & STYLE
# ==========================================
def set_style():
    sns.set_theme(style="whitegrid", context="paper", font_scale=1.4)
    plt.rcParams['font.family'] = 'serif'
    plt.rcParams['axes.edgecolor'] = '.3'
    plt.rcParams['axes.linewidth'] = 1.0
    return sns.color_palette("colorblind", n_colors=3)

# ==========================================
# 2. DATA CONSTRUCTION
# ==========================================
data = []

# --- Monotonic (Table 1) ---
# D=1.0: Native valid at 256. Leveled Unbounded.
# D=5.0: Native valid at 4. Leveled Unbounded.
# D=10.0: Native valid at 2. Leveled Unbounded.
data.extend([
    {'Exp': 'Monotonic', 'Density': 1.0, 'Method': 'Native', 'Max Length': 256},
    {'Exp': 'Monotonic', 'Density': 1.0, 'Method': 'Leveled', 'Max Length': 2048},
    {'Exp': 'Monotonic', 'Density': 5.0, 'Method': 'Native', 'Max Length': 4},
    {'Exp': 'Monotonic', 'Density': 5.0, 'Method': 'Leveled', 'Max Length': 2048},
    {'Exp': 'Monotonic', 'Density': 10.0, 'Method': 'Native', 'Max Length': 2},
    {'Exp': 'Monotonic', 'Density': 10.0, 'Method': 'Leveled', 'Max Length': 2048}
])

# --- Peak (UD) (Table 3) ---
# D=1.0: Native valid at 128. Leveled Unbounded.
# D=5.0: Native valid at 4. Leveled Unbounded (Green "infinity" in Table 3).
# D=10.0: Native valid at 2. Leveled valid at 2 (Yellow "T.O." at 4).
data.extend([
    {'Exp': 'Peak (UD)', 'Density': 1.0, 'Method': 'Native', 'Max Length': 128},
    {'Exp': 'Peak (UD)', 'Density': 1.0, 'Method': 'Leveled', 'Max Length': 2048},
    {'Exp': 'Peak (UD)', 'Density': 5.0, 'Method': 'Native', 'Max Length': 4},
    {'Exp': 'Peak (UD)', 'Density': 5.0, 'Method': 'Leveled', 'Max Length': 2048},
    {'Exp': 'Peak (UD)', 'Density': 10.0, 'Method': 'Native', 'Max Length': 2},
    {'Exp': 'Peak (UD)', 'Density': 10.0, 'Method': 'Leveled', 'Max Length': 2}
])

# --- ZigZag (UDUDU) (Table 3) ---
# D=1.0: Native valid at 128. Leveled Unbounded.
# D=5.0: Native valid at 4. Leveled valid at 4 (Yellow "T.O." at 8).
# D=10.0: Native valid at 2. Leveled valid at 2 (Yellow "T.O." at 4).
data.extend([
    {'Exp': 'ZigZag (UDUDU)', 'Density': 1.0, 'Method': 'Native', 'Max Length': 128},
    {'Exp': 'ZigZag (UDUDU)', 'Density': 1.0, 'Method': 'Leveled', 'Max Length': 2048},
    {'Exp': 'ZigZag (UDUDU)', 'Density': 5.0, 'Method': 'Native', 'Max Length': 4},
    {'Exp': 'ZigZag (UDUDU)', 'Density': 5.0, 'Method': 'Leveled', 'Max Length': 4},
    {'Exp': 'ZigZag (UDUDU)', 'Density': 10.0, 'Method': 'Native', 'Max Length': 2},
    {'Exp': 'ZigZag (UDUDU)', 'Density': 10.0, 'Method': 'Leveled', 'Max Length': 2}
])

df = pd.DataFrame(data)

# ==========================================
# 3. PLOTTING
# ==========================================
def plot_clean_data():
    palette = set_style()
    color_leveled = palette[0]  # Blue
    color_native = palette[1]   # Orange/Vermilion

    # Explicitly updated experiment titles
    experiments = ['Monotonic', 'Peak (UD)', 'ZigZag (UDUDU)']

    fig, axes = plt.subplots(1, 3, figsize=(15, 6), sharey=True)

    # Y-axis ticks mapping to powers of 2
    yticks = [2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048]
    yticklabels = ['2', '4', '8', '16', '32', '64', '128', '256', '512', '1024', 'Unb']

    for i, exp in enumerate(experiments):
        ax = axes[i]
        subset = df[df['Exp'] == exp]

        nat_data = subset[subset['Method'] == 'Native']
        lev_data = subset[subset['Method'] == 'Leveled']

        # Plot Native Line
        ax.plot(nat_data['Density'].astype(str), nat_data['Max Length'],
                marker='o', markersize=10, color=color_native, label='Native',
                linewidth=3, alpha=0.9)

        # Plot Leveled Line
        ax.plot(lev_data['Density'].astype(str), lev_data['Max Length'],
                marker='s', markersize=10, color=color_leveled, label='Leveled',
                linewidth=3, alpha=0.9)

        # Formatting
        ax.set_title(exp, fontsize=16, fontweight='bold', pad=15)
        ax.set_xlabel('Graph Density', fontweight='bold')
        ax.set_yscale('log', base=2)
        ax.set_ylim(1.5, 3000)
        ax.set_yticks(yticks)
        ax.set_yticklabels(yticklabels)
        ax.grid(True, which="major", axis="y", linestyle='-', alpha=0.3)

    # Set Y-label only on the first plot
    axes[0].set_ylabel('Max Reachable Path Length\n(Before Timeout)', fontsize=13, fontweight='bold')

    # Unified Legend
    handles, labels = axes[0].get_legend_handles_labels()
    fig.legend(handles, labels, loc='upper center', bbox_to_anchor=(0.5, 1.02),
               ncol=2, fontsize=13, frameon=False)

    plt.tight_layout()
    plt.subplots_adjust(top=0.88)
    plt.savefig('fig_medians.pdf')
    print("Saved fig_medians.pdf")
    plt.show()

if __name__ == "__main__":
    plot_clean_data()

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np
from matplotlib.lines import Line2D

def plot_dumbbell_offset_adjusted():
    # 1. Setup Data
    # 'Unb' is visualized as 2048 for log scale placement
    data = [
        # --- Exp 1: Monotonic ---
        # Text: "Monotonic Resilience... median performance line sits at 'Unbounded'"
        {'Exp': 'Monotonic', 'Density': 1.0, 'Native': 256, 'Leveled': 2048},
        {'Exp': 'Monotonic', 'Density': 5.0, 'Native': 4,   'Leveled': 2048},
        {'Exp': 'Monotonic', 'Density': 10.0,'Native': 2,   'Leveled': 2048},

        # --- Exp 3: Peak (UD) ---
        # Text: "Peak... retains robustness up to medium density (D=5.0)... Unbounded"
        {'Exp': 'Peak (UD)', 'Density': 1.0, 'Native': 128, 'Leveled': 2048},
        {'Exp': 'Peak (UD)', 'Density': 5.0, 'Native': 4,   'Leveled': 2048},
        {'Exp': 'Peak (UD)', 'Density': 10.0,'Native': 2,   'Leveled': 2},

        # --- Exp 4: ZigZag (UDUDU) ---
        # Text: "Zig-Zag... on dense graphs (D >= 5.0)... time out at short path lengths"
        {'Exp': 'ZigZag (UDUDU)', 'Density': 1.0, 'Native': 128, 'Leveled': 2048},
        {'Exp': 'ZigZag (UDUDU)', 'Density': 5.0, 'Native': 4,   'Leveled': 4},
        {'Exp': 'ZigZag (UDUDU)', 'Density': 10.0,'Native': 2,   'Leveled': 2},
    ]
    df = pd.DataFrame(data)

    # 2. Styling
    sns.set_theme(style="whitegrid", context="paper", font_scale=1.4)
    plt.rcParams['font.family'] = 'serif'
    colors = sns.color_palette("colorblind")
    c_lev = colors[0]  # Blue
    c_nat = colors[1]  # Orange

    # Create Figure
    fig, ax = plt.subplots(figsize=(10, 7))

    # 3. Create Y-positions
    # Note: ZigZag (UDUDU) is the bottom group, Monotonic is the top group
    experiments = ['ZigZag (UDUDU)', 'Peak (UD)', 'Monotonic']
    y_labels = []
    y_ticks = []

    current_y = 0

    # Vertical offset amount for collisions
    OFFSET = 0.15

    for exp in experiments:
        subset = df[df['Exp'] == exp].sort_values('Density', ascending=False)

        for _, row in subset.iterrows():
            dens = row['Density']
            nat_val = row['Native']
            lev_val = row['Leveled']

            # --- COLLISION DETECTION ---
            if nat_val == lev_val:
                # Collision: Offset markers vertically so both are visible
                # Label only if it's the first plotted item to avoid clutter, or rely on Legend
                ax.scatter(nat_val, current_y - OFFSET, color=c_nat, s=120, zorder=3)
                ax.scatter(lev_val, current_y + OFFSET, color=c_lev, s=120, marker='s', zorder=3)
                # Draw a tiny vertical connector
                ax.plot([nat_val, lev_val], [current_y - OFFSET, current_y + OFFSET], color='gray', lw=1, alpha=0.5)
            else:
                # No Collision: Standard Dumbbell
                ax.plot([nat_val, lev_val], [current_y, current_y], color='gray', lw=2, zorder=1)
                ax.scatter(nat_val, current_y, color=c_nat, s=120, zorder=3)
                ax.scatter(lev_val, current_y, color=c_lev, s=120, marker='s', zorder=3)

            y_labels.append(f"D={dens}")
            y_ticks.append(current_y)
            current_y += 1

        # Add extra space between groups
        current_y += 1

    # 4. Axes & Labels
    ax.set_yticks(y_ticks)
    ax.set_yticklabels(y_labels)

    # Group Labels (Headers)
    # Positions:
    # ZigZag: y=0,1,2 -> Center 1.0. Space at 3.
    # Peak: y=4,5,6 -> Center 5.0. Space at 7.
    # Mono: y=8,9,10 -> Center 9.0.
    # Text placements at 1.5, 5.5, 9.5 put them exactly between the groups or aligned with top?
    # Let's place them slightly above the top line of each group.
    # Top lines are 2, 6, 10.

    ax.text(1.5, 10.4, 'Monotonic', fontweight='bold', fontsize=12, ha='left', va='bottom')
    ax.text(1.5, 6.4, 'Peak (UD)', fontweight='bold', fontsize=12, ha='left', va='bottom')
    ax.text(1.5, 2.4, 'ZigZag (UDUDU)', fontweight='bold', fontsize=12, ha='left', va='bottom')

    # X-Axis Log Scale
    ax.set_xscale('log', base=2)
    ax.set_xlabel('Max Reachable Path Length (Before Timeout)')
    ax.set_xlim(1.5, 3500)

    # Custom Ticks
    ticks = [2, 4, 8, 32, 128, 512, 2048]
    labels = ['2', '4', '8', '32', '128', '512', 'Unbounded']
    ax.set_xticks(ticks)
    ax.set_xticklabels(labels)

    # Legend
    legend_elements = [
        Line2D([0], [0], marker='o', color='w', markerfacecolor=c_nat, markersize=10, label='Native'),
        Line2D([0], [0], marker='s', color='w', markerfacecolor=c_lev, markersize=10, label='Leveled'),
        Line2D([0], [0], color='gray', lw=2, label='Robustness Gain')
    ]
    ax.legend(handles=legend_elements, loc='lower right', frameon=True)

    ax.grid(True, axis='x', linestyle='--', alpha=0.5)
    ax.set_title('Robustness Gap: Native vs. Leveled ($|N|=10^4$)', fontweight='bold', pad=15)

    plt.tight_layout()
    plt.savefig('fig_dumbbell.pdf')
    print("Generated fig_dumbbell.pdf")
    plt.show()

if __name__ == "__main__":
    plot_dumbbell_offset_adjusted()
